<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MST Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; }
        .node { fill: #69b3a2; }
        .link { stroke: #999; stroke-opacity: 0.6; }
        .mst { stroke: red; stroke-width: 2; }
        .tooltip { position: absolute; text-align: center; padding: 4px; background: lightsteelblue; border: 1px solid #ccc; border-radius: 4px; }
    </style>
</head>
<body>
    <h1>Minimum Spanning Tree Visualization</h1>
    <svg width="800" height="600"></svg>
    <div class="tooltip" style="display: none;"></div>
    
    <script>
        const nodes = [
            { id: 'A' },
            { id: 'B' },
            { id: 'C' },
            { id: 'D' }
        ];

        const links = [
            { source: 'A', target: 'B', weight: 5 },
            { source: 'A', target: 'C', weight: 10 },
            { source: 'B', target: 'C', weight: 2 },
            { source: 'B', target: 'D', weight: 1 },
            { source: 'C', target: 'D', weight: 3 }
        ];

        const svg = d3.select("svg");
        const tooltip = d3.select(".tooltip");

        const link = svg.selectAll(".link")
            .data(links)
            .enter().append("line")
            .attr("class", "link")
            .attr("x1", d => getNodeX(d.source))
            .attr("y1", d => getNodeY(d.source))
            .attr("x2", d => getNodeX(d.target))
            .attr("y2", d => getNodeY(d.target))
            .on("mouseover", function(event, d) {
                tooltip.style("display", "block").html(`Weight: ${d.weight}`);
            })
            .on("mousemove", function(event) {
                tooltip.style("left", (event.pageX + 5) + "px")
                       .style("top", (event.pageY - 28) + "px");
            })
            .on("mouseout", function() {
                tooltip.style("display", "none");
            });

        const node = svg.selectAll(".node")
            .data(nodes)
            .enter().append("circle")
            .attr("class", "node")
            .attr("r", 8)
            .attr("cx", (d, i) => (i + 1) * 150) // Sample positioning
            .attr("cy", 300)
            .call(d3.drag() // Enable dragging
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

        svg.selectAll(".node")
            .data(nodes)
            .enter().append("text")
            .attr("x", (d, i) => (i + 1) * 150)
            .attr("y", 295)
            .text(d => d.id)
            .attr("text-anchor", "middle");

        function getNodeX(id) {
            const index = nodes.findIndex(n => n.id === id);
            return (index + 1) * 150;
        }

        function getNodeY(id) {
            return 300;
        }

        function dragstarted(event) {
            d3.select(this).raise().classed("active", true);
        }

        function dragged(event) {
            d3.select(this)
                .attr("cx", event.x)
                .attr("cy", event.y);
        }

        function dragended(event) {
            d3.select(this).classed("active", false);
        }

        // Implementing Prim's Algorithm for visualization
        function primsAlgorithm() {
            const selectedEdges = [];
            const connectedNodes = new Set();
            const minEdges = [...links].sort((a, b) => a.weight - b.weight);

            connectedNodes.add(nodes[0].id); // Start from the first node

            while (connectedNodes.size < nodes.length) {
                for (const edge of minEdges) {
                    if (connectedNodes.has(edge.source) && !connectedNodes.has(edge.target)) {
                        selectedEdges.push(edge);
                        connectedNodes.add(edge.target);
                        break;
                    } else if (connectedNodes.has(edge.target) && !connectedNodes.has(edge.source)) {
                        selectedEdges.push(edge);
                        connectedNodes.add(edge.source);
                        break;
                    }
                }
            }

            // Highlight selected edges as MST
            svg.selectAll(".mst").remove(); // Clear previous MST
            svg.selectAll(".link")
                .data(selectedEdges)
                .enter().append("line")
                .attr("class", "mst")
                .attr("x1", d => getNodeX(d.source))
                .attr("y1", d => getNodeY(d.source))
                .attr("x2", d => getNodeX(d.target))
                .attr("y2", d => getNodeY(d.target));
        }

        // Run Prim's Algorithm when the page loads
        primsAlgorithm();
    </script>
</body>
</html>
